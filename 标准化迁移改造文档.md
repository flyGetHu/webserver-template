# Salvo Template 标准化迁移改造文档

## 迁移目标与策略

本文档旨在将 `salvo-template` 项目中符合 Salvo 最佳实践的标准化部分迁移到 `webserver-template` 项目，同时保留现有业务中的个性化配置和功能。

### 迁移原则
- **标准化优先**: 采用 salvo-template 中经过验证的 Salvo 最佳实践
- **保留个性化**: 维护 webserver-template 中的业务特色功能
- **渐进式迁移**: 分阶段实施，确保系统稳定性
- **向后兼容**: 保持现有 API 接口的兼容性

## 项目特色分析

### Salvo Template (标准化源)
- **架构风格**: 简洁的 Salvo 标准架构
- **数据库**: RBatis + MySQL (Salvo 生态推荐)
- **配置管理**: Figment (Salvo 官方推荐)
- **中间件**: 标准 Salvo hoops 实现
- **错误处理**: 简洁的 Salvo Writer trait 实现
- **路由设计**: 标准 Salvo Router 模式

### WebServer Template (个性化目标)
- **架构风格**: DDD + 分层架构 (保留)
- **数据库**: SQLx + MySQL + Redis (保留)
- **响应格式**: 统一 ApiResponse 结构 (保留)
- **中间件栈**: 完整的企业级中间件 (保留)
- **依赖注入**: 自定义服务容器 (保留)
- **链路追踪**: request_id 机制 (保留)

## 标准化迁移核心方面

### 1. 配置管理系统标准化 (Figment + 分层结构)

**迁移策略:**
- **完全替换**: 使用 Figment 替换 config-rs，获得更好的 Salvo 生态集成
- **保留分层**: 维持分层配置文件结构 (default.toml + 环境特定配置)
- **增强功能**: 利用 Figment 的强大合并和验证能力

**新的配置架构:**
```rust
// 新的配置结构 (基于 salvo-template，但保持分层)
#[derive(Deserialize, Clone, Debug)]
pub struct Config {
    #[serde(default = "default_listen_addr")]
    pub listen_addr: String,
    pub server: ServerConfig,      // 保留现有服务器配置
    pub database: DatabaseConfig,  // 扩展数据库配置
    pub redis: RedisConfig,        // 保留 Redis 配置
    pub jwt: JwtConfig,           // 标准化 JWT 配置
    pub log: LogConfig,           // 引入标准日志配置
    pub tls: Option<TlsConfig>,   // 可选 TLS 配置
}

// 保留现有的子配置结构，但使用 Figment 加载
#[derive(Deserialize, Clone, Debug)]
pub struct ServerConfig {
    pub host: String,
    pub port: u16,
}

// 扩展数据库配置 (融合两个项目的优势)
#[derive(Deserialize, Clone, Debug)]
pub struct DatabaseConfig {
    pub url: String,
    #[serde(default = "default_pool_size")]
    pub pool_size: u32,
    pub min_idle: Option<u32>,
    #[serde(default = "default_connection_timeout")]
    pub connection_timeout: u64,
    #[serde(default = "default_statement_timeout")]
    pub statement_timeout: u64,
}
```

**配置加载逻辑:**
```rust
use figment::{Figment, providers::{Format, Toml, Env}};

impl Config {
    pub fn load() -> Result<Self, figment::Error> {
        // 获取运行模式
        let run_mode = std::env::var("RUN_MODE")
            .unwrap_or_else(|_| "development".into());
        
        // 使用 Figment 进行分层配置加载
        let config = Figment::new()
            // 1. 默认配置文件
            .merge(Toml::file("config/default.toml"))
            // 2. 环境特定配置文件 (可选)
            .merge(Toml::file(format!("config/{}.toml", run_mode)).nested())
            // 3. 环境变量覆盖 (最高优先级)
            .merge(Env::prefixed("APP_").global())
            // 4. 特殊环境变量处理
            .merge(Env::var("DATABASE_URL").map(|url| ("database.url", url)))
            .merge(Env::var("REDIS_URL").map(|url| ("redis.url", url)));
            
        config.extract()
    }
}
```

**配置文件结构保持不变:**
```
config/
├── default.toml           # 默认配置
├── development.toml       # 开发环境配置 (可选)
├── production.toml        # 生产环境配置 (可选)
└── test.toml             # 测试环境配置 (可选)
```

**具体改造步骤:**
1. **添加 Figment 依赖**: `figment = { version = "0.10.8", features = ["env", "toml"] }`
2. **创建新的配置模块**: 基于 salvo-template 的配置结构
3. **保留分层文件**: 现有的 config/ 目录结构不变
4. **迁移配置字段**: 将现有配置字段映射到新结构
5. **增强日志配置**: 引入 salvo-template 的完整日志配置
6. **移除 config-rs**: 完全替换为 Figment

### 2. 数据库层标准化

**迁移策略:**
- **保留现有**: 维持 SQLx + Repository 模式 (更适合企业级应用)
- **引入标准**: 采用 salvo-template 的数据库初始化模式
- **混合优化**: 结合两者优势，简化初始化流程

**具体改造:**
- 引入 salvo-template 的简洁数据库初始化逻辑
- 保留 Repository 模式和连接池管理
- 统一数据库配置结构
- 优化数据库连接管理代码

### 3. 错误处理系统融合

**迁移策略:**
- **保留个性化**: 维持统一 ApiResponse 格式和 request_id 追踪
- **引入标准**: 采用 salvo-template 的简洁 Writer trait 实现
- **最佳融合**: 结合标准化错误处理与个性化响应格式

**具体改造:**
- 引入 salvo-template 的 AppError 枚举设计
- 保留现有的 ApiResponse 统一响应格式
- 集成 request_id 到标准错误处理流程
- 优化错误处理的性能和可读性

### 4. 中间件系统标准化

**迁移策略:**
- **保留企业级**: 维持完整的中间件栈 (日志、异常处理、请求ID)
- **引入标准**: 采用 salvo-template 的标准 JWT 和 CORS 实现
- **优化整合**: 简化中间件配置，提升性能

**具体改造:**
- 引入 salvo-template 的标准 JWT hoop 实现
- 采用标准 CORS 处理方式
- 保留请求日志和全局异常处理中间件
- 移除前端模板相关的 404 处理
- 优化中间件执行顺序和性能

### 5. 路由系统优化

**迁移策略:**
- **保留模块化**: 维持现有的模块化路由结构
- **引入标准**: 采用 salvo-template 的标准路由组织方式
- **简化配置**: 优化路由注册和 OpenAPI 集成

**具体改造:**
- 引入 salvo-template 的简洁路由组织模式
- 保留现有的模块化结构 (auth、users、health)
- 移除前端页面路由，专注 API 设计
- 优化 OpenAPI 文档生成配置
- 统一路由中间件应用方式

### 6. 依赖注入系统标准化 (Salvo 最佳实践)

**Salvo 依赖注入最佳实践:**
Salvo 框架推荐使用 **Depot** 机制进行服务管理，这是最符合 Salvo 生态的依赖注入方式。

**标准化策略:**
- **采用 Depot 模式**: 使用 Salvo 原生的 Depot 进行服务注入
- **简化容器设计**: 避免过度工程化的 DI 容器
- **保留业务分层**: 维持现有的服务分层，但简化注入方式

**Salvo 标准依赖注入模式:**
```rust
// 1. 服务定义 (保持现有的服务结构)
#[derive(Clone)]
pub struct AppServices {
    pub config: Arc<Config>,
    pub user_repository: Arc<UserRepository>,
    pub auth_service: Arc<AuthService>,
    pub user_service: Arc<UserService>,
}

// 2. Depot 注入中间件 (Salvo 标准方式)
#[handler]
pub async fn inject_services(
    req: &mut Request,
    depot: &mut Depot,
    res: &mut Response,
    ctrl: &mut FlowCtrl,
) {
    // 注入服务到 Depot
    depot.insert("app_services", app_services.clone());
    ctrl.call_next(req, depot, res).await;
}

// 3. 处理器中使用服务 (简洁的获取方式)
#[handler]
pub async fn create_user(
    req: &mut Request,
    depot: &mut Depot,
    data: JsonBody<CreateUserRequest>,
) -> Result<Json<ApiResponse<User>>, AppError> {
    // 从 Depot 获取服务
    let services = depot.get::<AppServices>("app_services")?;
    
    // 使用服务
    let user = services.user_service.create_user(data.into_inner()).await?;
    
    Ok(Json(ApiResponse::new(user, request_id)))
}
```

**更友好的依赖注入方式:**
```rust
// 1. 扩展 trait 简化服务获取
pub trait DepotExt {
    fn get_user_service(&self) -> Result<Arc<UserService>, AppError>;
    fn get_auth_service(&self) -> Result<Arc<AuthService>, AppError>;
    fn get_config(&self) -> Result<Arc<Config>, AppError>;
}

impl DepotExt for Depot {
    fn get_user_service(&self) -> Result<Arc<UserService>, AppError> {
        let services = self.get::<AppServices>("app_services")
            .map_err(|_| AppError::Internal("Services not found".to_string()))?;
        Ok(services.user_service.clone())
    }
    
    fn get_auth_service(&self) -> Result<Arc<AuthService>, AppError> {
        let services = self.get::<AppServices>("app_services")
            .map_err(|_| AppError::Internal("Services not found".to_string()))?;
        Ok(services.auth_service.clone())
    }
}

// 2. 使用宏进一步简化
macro_rules! get_service {
    ($depot:expr, $service:ident) => {
        $depot.get::<AppServices>("app_services")
            .map_err(|_| AppError::Internal("Services not found".to_string()))?
            .$service.clone()
    };
}

// 3. 处理器使用示例
#[handler]
pub async fn create_user(
    depot: &mut Depot,
    data: JsonBody<CreateUserRequest>,
) -> Result<Json<ApiResponse<User>>, AppError> {
    let user_service = get_service!(depot, user_service);
    let user = user_service.create_user(data.into_inner()).await?;
    Ok(Json(ApiResponse::new(user, Uuid::new_v4())))
}
```

**应用初始化 (标准化方式):**
```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. 加载配置
    let config = Arc::new(Config::load()?);
    
    // 2. 初始化应用状态
    let app_state = Arc::new(AppState::new(db_pool, redis_pool));
    
    // 3. 创建服务容器
    let app_services = Arc::new(AppServices::new(config.clone(), app_state).await);
    
    // 4. 创建路由 (使用 Depot 注入)
    let router = Router::new()
        .hoop(inject_services_middleware(app_services))
        .push(create_routes());
    
    // 5. 启动服务器
    Server::new(TcpListener::new(&config.server.listen_addr).bind().await)
        .serve(router)
        .await;
    
    Ok(())
}

// 服务注入中间件
fn inject_services_middleware(services: Arc<AppServices>) -> impl Handler {
    move |req: &mut Request, depot: &mut Depot, res: &mut Response, ctrl: &mut FlowCtrl| {
        let services = services.clone();
        async move {
            depot.insert("app_services", services);
            ctrl.call_next(req, depot, res).await;
        }
    }
}
```

**迁移优势:**
- **原生支持**: 使用 Salvo 原生的 Depot 机制，无需第三方 DI 库
- **性能优化**: 避免复杂的反射和动态解析，提升性能
- **类型安全**: 编译时类型检查，减少运行时错误
- **简洁明了**: 代码更加直观，易于理解和维护
- **测试友好**: 易于进行单元测试和集成测试

### 7. 依赖管理标准化

**需要添加的标准化依赖:**
```toml
# Salvo 标准配置管理 (替换 config-rs)
figment = { version = "0.10.8", features = ["env", "toml"] }

# Salvo 标准日志支持
tracing-appender = "0.2.3"

# 其他 Salvo 生态工具
ulid = "1.1"  # 更好的 ID 生成 (可选)
```

**保留的个性化依赖:**
```toml
# 企业级数据库支持
sqlx = { version = "0.8.6", features = ["runtime-tokio-rustls", "mysql", "uuid", "time", "chrono"] }

# Redis 支持
redis = { version = "0.32.4", features = ["tokio-comp"] }
bb8 = "0.9.0"
bb8-redis = "0.24.0"

# 链路追踪
uuid = { version = "1.17.0", features = ["v4"] }
chrono = { version = "0.4.41", features = ["serde"] }
```

**需要移除的依赖:**
```toml
# 配置管理 (被 Figment 完全替代)
config = "0.15.13"
```

**Cargo.toml 更新示例:**
```toml
[dependencies]
# 保持现有的核心依赖
tokio = { version = "1.47.1", features = ["full"] }
salvo = { version = "0.72", features = ["cors", "oapi", "compression", "request-id"] }
serde = { version = "1.0.219", features = ["derive"] }
serde_json = "1.0.142"

# 新增：Figment 配置管理
figment = { version = "0.10.8", features = ["env", "toml"] }

# 增强：日志支持
tracing = "0.1.41"
tracing-subscriber = { version = "0.3.19", features = ["env-filter"] }
tracing-appender = "0.2.3"  # 新增

# 保留：数据库和缓存
sqlx = { version = "0.8.6", features = ["runtime-tokio-rustls", "mysql", "uuid", "time", "chrono"] }
redis = { version = "0.32.4", features = ["tokio-comp"] }
bb8 = "0.9.0"
bb8-redis = "0.24.0"

# 保留：其他工具
dotenvy = "0.15.7"
anyhow = "1.0.98"
async-trait = "0.1.88"
validator = { version = "0.20.0", features = ["derive"] }
thiserror = "2.0.12"
uuid = { version = "1.17.0", features = ["v4"] }
jsonwebtoken = "9.3.1"
chrono = { version = "0.4.41", features = ["serde"] }
time = "0.3.37"
argon2 = "0.5.3"

# 移除：config = "0.15.13"  # 被 Figment 替代
```

### 8. 项目结构优化

**标准化后的目录结构:**
```
src/
├── app/
│   ├── api/                    # API 层 (保留)
│   │   ├── middleware/         # 中间件 (保留 + 标准化)
│   │   ├── response.rs         # 响应格式 (保留)
│   │   └── routes.rs           # 路由定义 (标准化)
│   ├── config/                 # 配置管理 (标准化)
│   │   ├── mod.rs              # 主配置模块
│   │   ├── db_config.rs        # 数据库配置
│   │   └── log_config.rs       # 日志配置
│   ├── container.rs            # 依赖注入 (保留)
│   ├── domain/                 # 领域层 (保留)
│   │   ├── models/             # 领域模型
│   │   └── services/           # 领域服务
│   ├── infrastructure/         # 基础设施层 (保留)
│   │   └── persistence/        # 数据持久化
│   ├── modules/                # 功能模块 (保留)
│   │   ├── auth/               # 认证模块
│   │   └── users/              # 用户模块
│   ├── hoops/                  # Salvo 标准中间件 (新增)
│   │   ├── mod.rs
│   │   ├── jwt.rs              # JWT 认证
│   │   └── cors.rs             # CORS 处理
│   ├── state.rs                # 应用状态 (保留)
│   ├── error.rs                # 错误处理 (融合)
│   └── utils/                  # 工具模块 (新增)
└── main.rs                     # 应用入口 (标准化)
```

**结构调整说明:**
- **保留**: 现有的 DDD 分层结构和模块化设计
- **新增**: salvo-template 的标准 hoops 和 utils 模块
- **标准化**: 配置管理、路由组织、应用入口
- **融合**: 错误处理结合两者优势

### 9. 标准化迁移优先级

**第一阶段 (标准化基础设施):**
1. 引入 Figment 配置管理系统
2. 迁移标准 JWT 认证 hoops
3. 标准化 CORS 处理
4. 融合错误处理系统

**第二阶段 (优化现有功能):**
1. 简化路由组织结构
2. 优化中间件执行顺序
3. 统一 OpenAPI 文档生成
4. 保留个性化响应格式

**第三阶段 (性能与维护性):**
1. 优化依赖注入使用
2. 简化服务调用链路
3. 性能基准测试
4. 文档和示例更新

**保持不变 (个性化特色):**
- DDD 分层架构
- 统一 ApiResponse 格式
- request_id 链路追踪
- Redis 缓存支持
- SQLx + Repository 模式

### 10. 标准化实施建议

**阶段一: 配置系统迁移 (1-2周)**
- **第1步**: 添加 Figment 依赖，移除 config-rs
- **第2步**: 创建新的配置模块结构 (app/config/)
- **第3步**: 实现 Figment 配置加载逻辑
- **第4步**: 迁移现有配置文件格式
- **第5步**: 更新应用初始化代码
- **第6步**: 测试配置加载和环境变量覆盖

**详细配置迁移步骤:**
```rust
// 1. 创建 src/app/config/mod.rs
pub mod db_config;
pub mod log_config;

use figment::{Figment, providers::{Format, Toml, Env}};
use serde::Deserialize;

// 2. 定义新的配置结构
#[derive(Deserialize, Clone, Debug)]
pub struct Config {
    #[serde(default = "default_listen_addr")]
    pub listen_addr: String,
    pub server: ServerConfig,
    pub database: db_config::DatabaseConfig,
    pub redis: RedisConfig,
    pub jwt: JwtConfig,
    pub log: log_config::LogConfig,
    pub tls: Option<TlsConfig>,
}

// 3. 实现配置加载
impl Config {
    pub fn load() -> Result<Self, figment::Error> {
        let run_mode = std::env::var("RUN_MODE")
            .unwrap_or_else(|_| "development".into());
        
        Figment::new()
            .merge(Toml::file("config/default.toml"))
            .merge(Toml::file(format!("config/{}.toml", run_mode)).nested())
            .merge(Env::prefixed("APP_").global())
            .merge(Env::var("DATABASE_URL").map(|url| ("database.url", url)))
            .merge(Env::var("REDIS_URL").map(|url| ("redis.url", url)))
            .extract()
    }
}
```

**配置文件迁移示例:**
```toml
# config/default.toml (新格式，融合两个项目)
listen_addr = "127.0.0.1:3000"

[server]
host = "127.0.0.1"
port = 3000

[database]
url = "mysql://root:root123@192.168.100.149:3306/webserver_template"
pool_size = 10
connection_timeout = 30000
statement_timeout = 30000

[redis]
url = "redis://192.168.100.149:6379/"

[jwt]
secret = "xkL9mN2pQrS4tU6vW8yZ1aB3cD5eF7gH0iJ8kL2mN4oP6qR8sT0uV2wX4yZ6aB8cD0eF2gH"
expiry = 86400  # 24小时，单位：秒

[log]
filter_level = "info"
with_ansi = true
stdout = false
directory = "./logs"
file_name = "app.log"
rolling = "daily"
format = "full"
with_level = true
with_target = true
with_thread_ids = true
with_thread_names = true
with_source_location = true

# 可选的 TLS 配置
# [tls]
# cert = "path/to/cert.pem"
# key = "path/to/key.pem"
```

**阶段二: 依赖注入标准化 (1-2周)**
- **第1步**: 简化现有的依赖注入容器
- **第2步**: 实现 Depot 服务注入中间件
- **第3步**: 创建 DepotExt trait 简化服务获取
- **第4步**: 重构处理器使用标准 Depot 模式
- **第5步**: 优化服务初始化和注入流程

**依赖注入迁移步骤:**
```rust
// 1. 简化服务容器 (移除复杂的 DI 逻辑)
#[derive(Clone)]
pub struct AppServices {
    pub config: Arc<Config>,
    pub user_repository: Arc<UserRepository>,
    pub auth_service: Arc<AuthService>,
    pub user_service: Arc<UserService>,
}

// 2. 创建 Depot 扩展 trait
pub trait DepotServiceExt {
    fn get_app_services(&self) -> Result<Arc<AppServices>, AppError>;
    fn get_user_service(&self) -> Result<Arc<UserService>, AppError>;
    fn get_auth_service(&self) -> Result<Arc<AuthService>, AppError>;
}

// 3. 更新路由初始化
let router = Router::new()
    .hoop(inject_services_middleware(app_services))
    .push(modules::create_routes());
```

**阶段三: 功能融合 (2-3周)**
- 迁移 JWT 和 CORS hoops
- 融合错误处理系统
- 优化中间件栈配置
- 简化路由组织结构
- 保持 API 响应格式兼容

**阶段四: 性能优化 (1-2周)**
- 优化依赖注入使用
- 简化服务调用链路
- 性能基准测试
- 代码重构和清理

**阶段五: 文档和测试 (1周)**
- 更新项目文档
- 完善测试用例
- 创建迁移指南
- 性能对比报告

## 风险评估与缓解

**低风险项 (标准化迁移):**
- 配置管理系统标准化 (Figment 与现有配置并存)
- JWT 和 CORS 中间件标准化 (功能兼容)
- 路由结构优化 (保持 API 兼容性)

**中风险项:**
- 错误处理系统融合 (需要保持响应格式兼容)
- 中间件执行顺序调整 (可能影响性能)

**风险缓解策略:**
- **渐进式迁移**: 分阶段实施，每个阶段都可以回滚
- **兼容性保证**: 保持现有 API 响应格式不变
- **充分测试**: 每个阶段都进行完整的功能测试
- **性能监控**: 实时监控性能指标，及时发现问题
- **文档记录**: 详细记录每个变更，便于问题排查

## 预期收益

**标准化收益:**
- **配置管理优化**: Figment 提供更强大的配置合并和验证能力
- **依赖注入简化**: 使用 Salvo 原生 Depot 机制，避免第三方 DI 库
- **代码简洁性**: 采用 Salvo 最佳实践，减少样板代码
- **维护性提升**: 标准化的配置和中间件管理
- **性能优化**: 更高效的 JWT 处理、路由匹配和服务注入
- **生态兼容**: 更好地与 Salvo 生态系统集成
- **配置灵活性**: 支持多种配置源的优先级合并
- **类型安全**: 编译时配置验证和服务类型检查，减少运行时错误
- **测试友好**: 简化的依赖注入使单元测试和集成测试更容易

**保留优势:**
- **企业级特性**: 保持 DDD 架构和完整的中间件栈
- **链路追踪**: 维持 request_id 追踪能力
- **缓存支持**: 保留 Redis 集成
- **数据库优势**: 继续使用 SQLx 的类型安全特性

这个标准化迁移将在保持现有业务特色的基础上，引入 Salvo 的最佳实践，实现标准化与个性化的完美平衡。